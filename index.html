<html>

<head>
    <title>Tetris</title>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
            margin: 0;
        }

        h1 {
            background: #e74c3c;
            padding: 20px;
            text-align: center;
            color: #fff
        }

        .game-viewport {
            margin: 0px auto;
            border: 1px black solid;
        }

        .container {
            width: 800px;
            margin: 0px auto;
        }
    </style>
</head>

<body>
    <header>
        <h1>Tetris</h1>
    </header>
    <div>
        <div class="container">
            <canvas id="game-viewport" class="game-viewport" width="200" height="480"></canvas>

            <h2>About</h2>
            <p><b>A</b> (left) and <b>D</b> (right) move the tetromino sideways. <b>W</b> rotates the tetromino clockwise. <b>S</b> drops the tetromino
            one row.</p>
        </div>
    </div>
</body>

<script>
    var i = {
        name: "I",
        rotations: [
            0x0F00, 0x2222, 0x00F0, 0x4444
        ],
        color: 'red'
    };

    var j = {
        name: "J",
        rotations: [
            0x8E00, 0x6440, 0x0E20, 0x44C0
        ],
        color: 'orange'
    }

    var l = {
        name: "L",
        rotations: [
            0x2E00, 0x4460, 0x0E80, 0xC440
        ],
        color: 'yellow'
    }

    var o = {
        name: "O",
        rotations: [
            0x6600, 0x6600, 0x6600, 0x6600
        ],
        color: 'green'
    }

    var s = {
        name: "S",
        rotations: [
            0x6C00, 0x4620, 0x06C0, 0x8C40
        ],
        color: 'blue'
    }

    var t = {
        name: "T",
        rotations: [
            0x4E00, 0x4640, 0x0E40, 0x4C40
        ],
        color: 'cyan'
    }

    var z = {
        name: "Z",
        rotations: [
            0xC600, 0x2640, 0x0C60, 0x4C80
        ],
        color: 'magenta'
    }

    function drop() {
        state.y += 1;
    }

    function move(direction) {
        var nextX = state.x + direction;
        if (!occupied(nextX, state.y, state.currentShape, state.rotationIdx)) {
            state.x = nextX;
        };
    }

    function occupied(x, y, shape, rotationIdx) {
        var result = false;

        each(x, y, shape, rotationIdx, function (x, y) {
            if ((x < 0) || (x * blockSize >= width) || (y < 0) || (y * blockSize >= height)) {
                result = true;
            }
        })

        return result;
    }

    var blockSize = 20;
    var stepTime = 2;

    var canvas = document.getElementById("game-viewport");
    var width = canvas.width;
    var height = canvas.height;
    var ctx = canvas.getContext("2d");

    // Game State

    let state = {
        rotationIdx: 0,
        currentShape: z,
        timePlayed: 0,
        x: 5,
        y: 0,
        actions: []
    }

    // Input

    var KEY = {
        up: "up",
        down: "down",
        left: "left",
        right: "right"
    }

    var keyMap = {
        87: KEY.up, // w
        65: KEY.left, // a
        83: KEY.down, // s
        68: KEY.right, // d
    }

    function keyup(event) {
        var key = keyMap[event.keyCode];
        state.actions.push(key);
    }

    window.addEventListener("keyup", keyup, false);

    // Game Loop

    function update(progress) {

        var nextAction = state.actions.shift();

        switch (nextAction) {
            case KEY.left:
                move(-1);
                break;
            case KEY.right:
                move(1);
                break;
            case KEY.up:
                rotate();
                break;
            case KEY.down:
                drop();
                break;
        }

        state.timePlayed += progress;
        if (state.timePlayed > stepTime) {
            drop();
            state.timePlayed -= stepTime;
        }
    }

    function drawBlock(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);

        ctx.save();
    }

    function rotate() {
        // Each shape has exactly 4 rotations
        var nextIndex = state.rotationIdx == 3 ? 0 : state.rotationIdx + 1;

        if (!occupied(state.x, state.y, state.currentShape, nextIndex)){
            state.rotationIdx = nextIndex;
        }
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);

        each(state.x, state.y, state.currentShape, state.rotationIdx, drawBlock);
    }

    function each(x, y, shape, rotationIdx, func) {
        var row = 0;
        var col = 0;
        var rotation = shape.rotations[rotationIdx];

        for (var bit = 0x8000; bit > 0; bit = bit >> 1) {
            if (rotation & bit) {
                func(col + x, row + y, shape.color);
            }

            if (++col === 4) {
                col = 0;
                ++row;
            }
        }
    }

    function run() {
        function loop(timestamp) {
            var progress = timestamp - lastRender;

            update(progress / 1000);
            draw();

            lastRender = timestamp;
            window.requestAnimationFrame(loop);
        }

        var lastRender = 0;
        window.requestAnimationFrame(loop);
    }

    run();
</script>

</html>